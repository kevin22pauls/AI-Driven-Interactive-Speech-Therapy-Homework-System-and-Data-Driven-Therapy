<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Speech Homework Demo</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width:700px; }
    h2 { margin-bottom: 6px; }
    .patient-id-section {
      background: #f0f8ff;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 15px;
      border-left: 4px solid #4a90e2;
    }
    .patient-id-section label {
      font-weight: bold;
      margin-right: 10px;
    }
    .patient-id-section input {
      padding: 6px 10px;
      border: 2px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      width: 250px;
    }
    .patient-id-section input:focus {
      outline: none;
      border-color: #4a90e2;
    }
    .patient-id-section small {
      display: block;
      margin-top: 5px;
      color: #666;
      font-size: 12px;
    }
    .session-info {
      background: #e8f5e9;
      padding: 8px 12px;
      border-radius: 4px;
      margin: 10px 0;
      font-size: 12px;
      color: #2e7d32;
      display: none;
    }
    .session-info.active {
      display: block;
    }
    #prompt { font-size: 18px; margin: 10px 0; white-space: pre-wrap; }
    button { padding: 8px 12px; margin-right: 8px; }
    #status { margin-top: 10px; color: #333; }
    pre { background:#f3f3f3; padding:10px; border-radius:6px; max-height:300px; overflow:auto; }
    .warn { color: darkred; }
  </style>
</head>
<body>
  <h2>Speech Homework Demo</h2>

  <div class="patient-id-section">
    <label for="patientId">Patient ID:</label>
    <input
      type="text"
      id="patientId"
      placeholder="e.g., john_doe, patient123"
      autocomplete="off"
    />
    <small>ðŸ’¡ Enter a unique ID to track your progress in the dashboard</small>
  </div>

  <div class="session-info" id="sessionInfo">
    âœ“ Session active: <span id="sessionId"></span>
  </div>

  <div id="prompt">Click "Get Prompt" to start</div>
  <button id="getPrompt">Get Prompt</button>
  <button id="newObject" style="display: none;">New Object</button>
  <button id="startRec" disabled>Start Recording</button>
  <button id="stopRec" disabled>Stop</button>
  <div id="status"></div>
  <pre id="result"></pre>

<script>
/* ======== CONFIG ======== */
const BACKEND = "http://127.0.0.1:8000"; // <-- make sure this matches your backend
/* ======================== */

const promptEl = document.getElementById("prompt");
const getBtn = document.getElementById("getPrompt");
const newObjBtn = document.getElementById("newObject");
const startBtn = document.getElementById("startRec");
const stopBtn = document.getElementById("stopRec");
const statusEl = document.getElementById("status");
const resultEl = document.getElementById("result");
const patientIdInput = document.getElementById("patientId");
const sessionInfoEl = document.getElementById("sessionInfo");
const sessionIdSpan = document.getElementById("sessionId");

let session = null;
let mediaRecorder = null;
let audioChunks = [];
let silenceTimeout = null;
let audioContext, analyser, sourceNode;

async function getPrompt() {
  statusEl.innerText = "Requesting prompt...";
  try {
    let response, json;

    if (!session || !session.session_id) {
      // Get patient ID from input (or generate default)
      let patientId = patientIdInput.value.trim();
      if (!patientId) {
        patientId = "anonymous_" + Date.now();
        patientIdInput.value = patientId;
      }

      // Create session ID with patient ID prefix
      const sessionId = `${patientId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

      // First time - start a new session
      response = await fetch(`${BACKEND}/session/start`, { method: "POST" });
      if (!response.ok) throw new Error("Failed to start session");
      json = await response.json();

      // Override the server-generated session_id with our custom one
      json.session_id = sessionId;

      // Lock the patient ID input and show session info
      patientIdInput.disabled = true;
      sessionInfoEl.classList.add('active');
      sessionIdSpan.textContent = sessionId;
      newObjBtn.style.display = "inline-block";
    } else {
      // Already have a session - get next prompt for same object
      const formData = new FormData();
      formData.append("session_id", session.session_id);

      response = await fetch(`${BACKEND}/session/next-prompt`, {
        method: "POST",
        body: formData
      });
      if (!response.ok) throw new Error("Failed to get next prompt");
      json = await response.json();
    }

    // Update session data
    session = {
      session_id: json.session_id,
      prompt_text: json.prompt_text,
      object: json.object,
      expected_answer: json.expected_answer
    };

    promptEl.innerText = `Object: ${session.object}\nPrompt: ${session.prompt_text}`;
    startBtn.disabled = false;
    statusEl.innerText = "Prompt ready. Click 'Start Recording' to answer.";
  } catch (e) {
    console.error(e);
    statusEl.innerText = "Could not fetch prompt. Is backend running? " + e.message;
    startBtn.disabled = true;
  }
}

getBtn.addEventListener("click", getPrompt);

async function newObject() {
  if (!session || !session.session_id) {
    statusEl.innerText = "Please get a prompt first before changing objects.";
    return;
  }

  statusEl.innerText = "Getting new object...";
  try {
    const formData = new FormData();
    formData.append("session_id", session.session_id);

    const response = await fetch(`${BACKEND}/session/change-object`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) throw new Error("Failed to change object");
    const json = await response.json();

    // Update session data
    session = {
      session_id: json.session_id,
      prompt_text: json.prompt_text,
      object: json.object,
      expected_answer: json.expected_answer
    };

    promptEl.innerText = `Object: ${session.object}\nPrompt: ${session.prompt_text}`;
    startBtn.disabled = false;
    statusEl.innerText = "New object selected. Click 'Start Recording' to answer.";
    resultEl.innerHTML = ""; // Clear previous results
  } catch (e) {
    console.error(e);
    statusEl.innerText = "Could not change object: " + e.message;
  }
}

newObjBtn.addEventListener("click", newObject);

startBtn.addEventListener("click", async () => {
  startBtn.disabled = true;
  stopBtn.disabled = false;
  statusEl.innerText = "Requesting microphone permission...";
  audioChunks = [];

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = e => {
      if (e.data && e.data.size > 0) audioChunks.push(e.data);
    };
    mediaRecorder.onstop = async () => {
      statusEl.innerText = "Recording stopped. Uploading...";
      const blob = new Blob(audioChunks, { type: "audio/webm" });
      await uploadRecording(blob);
    };

    // Setup simple client-side VAD (energy-based)
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      sourceNode.connect(analyser);
      monitorSilence(); // start monitoring
    } catch (e) {
      console.warn("AudioContext VAD not available", e);
    }

    mediaRecorder.start();
    statusEl.innerText = "Recording... Speak now.";
    // fallback auto-stop after 8 seconds
    setTimeout(() => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        stopRecording();
      }
    }, 8000);

  } catch (err) {
    console.error("microphone error", err);
    statusEl.innerText = "Microphone error: " + err.message;
    startBtn.disabled = false;
    stopBtn.disabled = true;
  }
});

stopBtn.addEventListener("click", stopRecording);

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === "recording") {
    mediaRecorder.stop();
  }
  stopBtn.disabled = true;
  startBtn.disabled = false;
  if (audioContext) {
    try { audioContext.close(); } catch(e){}
    audioContext = null;
    analyser = null;
  }
}

function monitorSilence() {
  const bufferLength = analyser.fftSize;
  const data = new Uint8Array(bufferLength);
  const check = () => {
    if (!analyser) return;
    analyser.getByteTimeDomainData(data);
    let sum = 0;
    for (let i = 0; i < bufferLength; i++) {
      const val = (data[i] - 128) / 128;
      sum += val * val;
    }
    const rms = Math.sqrt(sum / bufferLength);
    // threshold tuned for quiet rooms; raise if your environment is noisy
    if (rms > 0.02) {
      if (silenceTimeout) {
        clearTimeout(silenceTimeout);
        silenceTimeout = null;
      }
      silenceTimeout = setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          stopRecording();
        }
      }, 900); // stop after 900ms of silence
    }
    requestAnimationFrame(check);
  };
  check();
}

async function uploadRecording(blob) {
  if (!session) {
    statusEl.innerText = "No session info found. Click Get Prompt first.";
    return;
  }

  const form = new FormData();
  form.append("session_id", session.session_id);
  form.append("object_name", session.object);
  form.append("prompt_text", session.prompt_text);
  form.append("expected_answer", session.expected_answer || "");
  // name the file .webm â€” backend will accept common formats if ffmpeg in PATH
  form.append("audio", blob, "recording.webm");

  try {
    const res = await fetch(`${BACKEND}/record`, { method: "POST", body: form });
    if (!res.ok) {
      const txt = await res.text();
      throw new Error(`Server returned ${res.status}: ${txt}`);
    }
    const json = await res.json();
    displayResults(json);
    statusEl.innerText = "Analysis complete";
  } catch (e) {
    statusEl.innerText = "Upload failed: " + e.message;
    resultEl.innerText = "";
    console.error("upload error", e);
  }
}

function displayResults(data) {
  // Create a formatted display of results
  let html = "<h3>Analysis Results</h3>";

  // Display transcript
  html += `<div><strong>Transcript:</strong> ${data.transcript || "(no speech detected)"}</div>`;

  // Display semantic evaluation if present
  if (data.semantic_evaluation) {
    const eval = data.semantic_evaluation;
    const classColor = {
      "correct": "#2ecc71",
      "partial": "#f39c12",
      "wrong": "#e74c3c"
    }[eval.classification] || "#333";

    html += `<div style="margin-top: 15px; padding: 10px; background-color: #f8f8f8; border-radius: 6px;">`;
    html += `<h4>Semantic Evaluation</h4>`;
    html += `<div><strong>Classification:</strong> <span style="color: ${classColor}; font-weight: bold;">${eval.classification.toUpperCase()}</span></div>`;
    html += `<div><strong>Similarity Score:</strong> ${(eval.similarity_score * 100).toFixed(1)}%</div>`;
    html += `<div><strong>Confidence:</strong> ${(eval.confidence * 100).toFixed(0)}%</div>`;
    html += `<div><strong>Object Mentioned:</strong> ${eval.object_mentioned ? "Yes" : "No"}</div>`;
    html += `<div><strong>Explanation:</strong> ${eval.explanation}</div>`;

    // Display semantic features if present
    if (eval.semantic_features) {
      html += `<div style="margin-top: 10px;"><strong>Clinical Insights:</strong>`;
      html += `<ul style="margin: 5px 0;">`;
      html += `<li>Word count: ${eval.semantic_features.word_count || 0}</li>`;
      if (eval.semantic_features.response_type) {
        html += `<li>Response type: ${eval.semantic_features.response_type}</li>`;
      }
      if (eval.semantic_features.has_paraphrase) {
        html += `<li>Paraphrasing detected (${eval.semantic_features.paraphrase_quality})</li>`;
      }
      if (eval.semantic_features.substituted_term) {
        html += `<li>Word substitution: "${eval.semantic_features.substituted_term}"</li>`;
      }
      html += `</ul></div>`;
    }
    html += `</div>`;
  }

  // Display phoneme analysis if present
  if (data.phoneme_analysis && !data.phoneme_analysis.error) {
    const phoneme = data.phoneme_analysis;
    html += `<div style="margin-top: 15px; padding: 10px; background-color: #e8f4f8; border-radius: 6px;">`;
    html += `<h4>Phoneme-Level Analysis</h4>`;
    html += `<div><strong>Phoneme Error Rate (PER):</strong> ${(phoneme.per * 100).toFixed(1)}%</div>`;
    html += `<div><strong>Total Phonemes:</strong> ${phoneme.total_phonemes}</div>`;
    html += `<div><strong>Errors Detected:</strong> ${phoneme.error_count}</div>`;

    // Error breakdown
    if (phoneme.error_summary) {
      html += `<div style="margin-top: 8px;"><strong>Error Types:</strong>`;
      html += `<ul style="margin: 5px 0;">`;
      if (phoneme.error_summary.substitution > 0) {
        html += `<li>Substitutions: ${phoneme.error_summary.substitution}</li>`;
      }
      if (phoneme.error_summary.deletion > 0) {
        html += `<li>Deletions: ${phoneme.error_summary.deletion}</li>`;
      }
      if (phoneme.error_summary.insertion > 0) {
        html += `<li>Insertions: ${phoneme.error_summary.insertion}</li>`;
      }
      html += `</ul></div>`;
    }

    // Problematic phonemes
    if (phoneme.problematic_phonemes && Object.keys(phoneme.problematic_phonemes).length > 0) {
      html += `<div style="margin-top: 8px;"><strong>Problematic Phonemes:</strong> `;
      const problems = Object.entries(phoneme.problematic_phonemes)
        .map(([ph, count]) => `${ph} (${count}x)`)
        .join(', ');
      html += `${problems}</div>`;
    }

    // Clinical notes
    if (phoneme.clinical_notes && phoneme.clinical_notes.length > 0) {
      html += `<div style="margin-top: 10px; padding: 8px; background-color: #fff3cd; border-left: 3px solid #ffc107;">`;
      html += `<strong>Clinical Insights:</strong>`;
      html += `<ul style="margin: 5px 0;">`;
      phoneme.clinical_notes.forEach(note => {
        html += `<li>${note}</li>`;
      });
      html += `</ul></div>`;
    }

    // Detailed errors (collapsible)
    if (phoneme.errors && phoneme.errors.length > 0) {
      html += `<details style="margin-top: 10px;">`;
      html += `<summary style="cursor: pointer; font-weight: bold;">Detailed Phoneme Errors (${phoneme.errors.length})</summary>`;
      html += `<table style="width: 100%; margin-top: 8px; border-collapse: collapse; font-size: 12px;">`;
      html += `<tr style="background-color: #f0f0f0;"><th>Type</th><th>Word</th><th>Expected</th><th>Actual</th><th>Position</th></tr>`;
      phoneme.errors.forEach(err => {
        const errorTypeColor = {
          'substitution': '#ff9800',
          'deletion': '#f44336',
          'insertion': '#2196f3'
        }[err.type] || '#333';
        html += `<tr style="border-bottom: 1px solid #ddd;">`;
        html += `<td style="padding: 4px; color: ${errorTypeColor}; font-weight: bold;">${err.type}</td>`;
        html += `<td style="padding: 4px;">${err.word || '-'}</td>`;
        html += `<td style="padding: 4px;">${err.expected || '-'}</td>`;
        html += `<td style="padding: 4px;">${err.actual || '-'}</td>`;
        html += `<td style="padding: 4px;">${err.position}</td>`;
        html += `</tr>`;
      });
      html += `</table></details>`;
    }
    html += `</div>`;
  }

  // Display fluency analysis if present
  if (data.fluency_analysis && !data.fluency_analysis.error) {
    const fluency = data.fluency_analysis;
    html += `<div style="margin-top: 15px; padding: 10px; background-color: #f0f8ff; border-radius: 6px;">`;
    html += `<h4>Fluency & Stuttering Analysis</h4>`;

    // Key metrics
    html += `<div><strong>Longest Fluent Run:</strong> ${fluency.longest_fluent_run} words</div>`;
    html += `<div><strong>Fluency Percentage:</strong> ${fluency.fluency_percentage.toFixed(1)}%</div>`;
    html += `<div><strong>Dysfluencies per 100 words:</strong> ${fluency.dysfluencies_per_100_words.toFixed(1)}</div>`;
    html += `<div><strong>Dysfluencies per minute:</strong> ${fluency.dysfluencies_per_minute.toFixed(1)}</div>`;

    // Pause breakdown
    if (fluency.total_pauses > 0) {
      html += `<div style="margin-top: 8px;"><strong>Pauses Detected:</strong> ${fluency.total_pauses}`;
      html += ` (${fluency.hesitation_count} hesitations, ${fluency.block_count} blocks)</div>`;
    }

    // Stuttering events summary
    if (fluency.stuttering_events && fluency.stuttering_events.length > 0) {
      const repetitions = fluency.stuttering_events.filter(e => e.type === 'repetition').length;
      const interjections = fluency.stuttering_events.filter(e => e.type === 'interjection').length;
      const prolongations = fluency.stuttering_events.filter(e => e.type === 'prolongation').length;

      html += `<div style="margin-top: 8px;"><strong>Stuttering Events:</strong> ${fluency.stuttering_events.length}`;
      if (repetitions > 0) html += ` (${repetitions} repetition(s)`;
      if (interjections > 0) html += `, ${interjections} interjection(s)`;
      if (prolongations > 0) html += `, ${prolongations} prolongation(s)`;
      html += `)</div>`;
    }

    // Clinical notes
    if (fluency.clinical_notes && fluency.clinical_notes.length > 0) {
      html += `<div style="margin-top: 10px; padding: 8px; background-color: #fff3cd; border-left: 3px solid #ffc107;">`;
      html += `<strong>Fluency Insights:</strong>`;
      html += `<ul style="margin: 5px 0;">`;
      fluency.clinical_notes.forEach(note => {
        html += `<li>${note}</li>`;
      });
      html += `</ul></div>`;
    }

    // Detailed stuttering events (collapsible)
    if (fluency.stuttering_events && fluency.stuttering_events.length > 0) {
      html += `<details style="margin-top: 10px;">`;
      html += `<summary style="cursor: pointer; font-weight: bold;">Detailed Stuttering Events (${fluency.stuttering_events.length})</summary>`;
      html += `<table style="width: 100%; margin-top: 8px; border-collapse: collapse; font-size: 12px;">`;
      html += `<tr style="background-color: #f0f0f0;"><th>Type</th><th>Position</th><th>Word</th><th>Details</th></tr>`;
      fluency.stuttering_events.forEach(event => {
        const typeColor = {
          'repetition': '#ff9800',
          'interjection': '#9c27b0',
          'prolongation': '#f44336'
        }[event.type] || '#333';

        let details = '';
        if (event.type === 'repetition') {
          details = `Repeated ${event.repetition_count}x`;
        } else if (event.type === 'prolongation' && event.duration) {
          details = `Duration: ${event.duration.toFixed(2)}s`;
        }

        html += `<tr style="border-bottom: 1px solid #ddd;">`;
        html += `<td style="padding: 4px; color: ${typeColor}; font-weight: bold;">${event.type}</td>`;
        html += `<td style="padding: 4px;">${event.position}</td>`;
        html += `<td style="padding: 4px;">${event.word}</td>`;
        html += `<td style="padding: 4px;">${details}</td>`;
        html += `</tr>`;
      });
      html += `</table></details>`;
    }

    // Detailed pauses (collapsible)
    if (fluency.pauses && fluency.pauses.length > 0) {
      html += `<details style="margin-top: 10px;">`;
      html += `<summary style="cursor: pointer; font-weight: bold;">Detailed Pauses (${fluency.pauses.length})</summary>`;
      html += `<table style="width: 100%; margin-top: 8px; border-collapse: collapse; font-size: 12px;">`;
      html += `<tr style="background-color: #f0f0f0;"><th>Type</th><th>Duration</th><th>Location</th><th>Context</th></tr>`;
      fluency.pauses.forEach(pause => {
        const pauseColor = pause.type === 'block' ? '#f44336' : '#ff9800';
        html += `<tr style="border-bottom: 1px solid #ddd;">`;
        html += `<td style="padding: 4px; color: ${pauseColor}; font-weight: bold;">${pause.type}</td>`;
        html += `<td style="padding: 4px;">${pause.duration.toFixed(2)}s</td>`;
        html += `<td style="padding: 4px;">${pause.location}</td>`;
        html += `<td style="padding: 4px;">${pause.before_word || '?'} â†’ ${pause.after_word || '?'}</td>`;
        html += `</tr>`;
      });
      html += `</table></details>`;
    }

    html += `</div>`;
  }

  // Display other metrics
  html += `<div style="margin-top: 15px;">`;
  html += `<h4>Speech Metrics</h4>`;
  if (data.wer !== null) {
    html += `<div><strong>Word Error Rate (WER):</strong> ${(data.wer * 100).toFixed(1)}%</div>`;
  }
  html += `<div><strong>Speech Rate:</strong> ${data.speech_rate ? data.speech_rate.toFixed(1) : "N/A"} words/min</div>`;
  html += `<div><strong>Pause Ratio:</strong> ${data.pause_ratio ? (data.pause_ratio * 100).toFixed(1) : "N/A"}%</div>`;
  html += `</div>`;

  // Show raw JSON in collapsible section
  html += `<details style="margin-top: 15px;">`;
  html += `<summary style="cursor: pointer;">Raw JSON Response</summary>`;
  html += `<pre style="margin-top: 10px;">${JSON.stringify(data, null, 2)}</pre>`;
  html += `</details>`;

  resultEl.innerHTML = html;
}
</script>
</body>
</html>
