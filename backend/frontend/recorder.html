<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Speech Homework Demo</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width:700px; }
    h2 { margin-bottom: 6px; }
    .patient-id-section {
      background: #f0f8ff;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 15px;
      border-left: 4px solid #4a90e2;
    }
    .patient-id-section label {
      font-weight: bold;
      margin-right: 10px;
    }
    .patient-id-section input {
      padding: 6px 10px;
      border: 2px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      width: 250px;
    }
    .patient-id-section input:focus {
      outline: none;
      border-color: #4a90e2;
    }
    .patient-id-section small {
      display: block;
      margin-top: 5px;
      color: #666;
      font-size: 12px;
    }
    .session-info {
      background: #e8f5e9;
      padding: 8px 12px;
      border-radius: 4px;
      margin: 10px 0;
      font-size: 12px;
      color: #2e7d32;
      display: none;
    }
    .session-info.active {
      display: block;
    }
    #prompt { font-size: 18px; margin: 10px 0; white-space: pre-wrap; }
    button { padding: 8px 12px; margin-right: 8px; }
    #status { margin-top: 10px; color: #333; }
    pre { background:#f3f3f3; padding:10px; border-radius:6px; max-height:300px; overflow:auto; }
    .warn { color: darkred; }
  </style>
</head>
<body>
  <h2>Speech Homework Demo</h2>

  <div class="patient-id-section">
    <label for="patientId">Patient ID:</label>
    <input
      type="text"
      id="patientId"
      placeholder="e.g., john_doe, patient123"
      autocomplete="off"
    />
    <small>üí° Enter a unique ID to track your progress in the dashboard</small>
  </div>

  <div class="patient-id-section" style="border-left-color: #9c27b0;">
    <label for="objectName">Object:</label>
    <input
      type="text"
      id="objectName"
      placeholder="e.g., toothbrush, umbrella, spoon"
      autocomplete="off"
    />
    <small>‚ú® Enter ANY object - the system will generate prompts automatically</small>
    <div style="margin-top: 8px;">
      <button id="generatePrompts" style="padding: 6px 12px; font-size: 13px; background: #9c27b0; color: white; border: none; border-radius: 4px; cursor: pointer;">
        Generate Prompts
      </button>
      <span id="ollamaStatus" style="margin-left: 10px; font-size: 12px;"></span>
    </div>
  </div>

  <div class="session-info" id="sessionInfo">
    ‚úì Session active: <span id="sessionId"></span>
  </div>

  <div id="prompt">Enter an object and click "Generate Prompts" to start</div>
  <button id="getPrompt" disabled>Get Prompt</button>
  <button id="newObject" style="display: none;">New Object</button>
  <button id="startRec" disabled>Start Recording</button>
  <button id="stopRec" disabled>Stop</button>
  <div id="status"></div>
  <pre id="result"></pre>

<script>
/* ======== CONFIG ======== */
const BACKEND = "http://127.0.0.1:8001"; // <-- make sure this matches your backend
/* ======================== */

const promptEl = document.getElementById("prompt");
const getBtn = document.getElementById("getPrompt");
const newObjBtn = document.getElementById("newObject");
const startBtn = document.getElementById("startRec");
const stopBtn = document.getElementById("stopRec");
const statusEl = document.getElementById("status");
const resultEl = document.getElementById("result");
const patientIdInput = document.getElementById("patientId");
const sessionInfoEl = document.getElementById("sessionInfo");
const sessionIdSpan = document.getElementById("sessionId");
const objectNameInput = document.getElementById("objectName");
const generatePromptsBtn = document.getElementById("generatePrompts");
const ollamaStatusEl = document.getElementById("ollamaStatus");

let session = null;
let generatedPrompts = null; // Store generated prompts for the current object
let mediaRecorder = null;
let audioChunks = [];
let silenceTimeout = null;
let audioContext, analyser, sourceNode;

async function getPrompt() {
  if (!generatedPrompts) {
    statusEl.innerText = "‚ö†Ô∏è Please generate prompts for an object first!";
    return;
  }

  statusEl.innerText = "Selecting prompt...";
  try {
    // Create session if first time
    if (!session || !session.session_id) {
      // Get patient ID from input (or generate default)
      let patientId = patientIdInput.value.trim();
      if (!patientId) {
        patientId = "anonymous_" + Date.now();
        patientIdInput.value = patientId;
      }

      // Create session ID with patient prefix
      const timestamp = Date.now();
      const randomStr = Math.random().toString(36).substr(2, 9);
      const sessionId = `${patientId}_${timestamp}_${randomStr}`;

      // Initialize session with object and empty used prompts
      session = {
        session_id: sessionId,
        object: generatedPrompts.object,
        used_prompts: []
      };

      // Lock the patient ID input and show session info
      patientIdInput.disabled = true;
      sessionInfoEl.classList.add('active');
      sessionIdSpan.textContent = sessionId;
      newObjBtn.style.display = "inline-block";
    }

    // Get all available prompts (questions + sentences)
    const allPrompts = [];

    // Add questions
    generatedPrompts.questions.forEach(q => {
      allPrompts.push({
        text: q.text,
        type: "question",
        expected_answers: q.expected_answers
      });
    });

    // Add sentences
    generatedPrompts.sentences.forEach(s => {
      allPrompts.push({
        text: s.text,
        type: "sentence",
        expected_answers: [s.text] // For sentences, expected answer is the sentence itself
      });
    });

    // Filter out already used prompts
    const availablePrompts = allPrompts.filter(p => !session.used_prompts.includes(p.text));

    // If all prompts used, reset
    if (availablePrompts.length === 0) {
      session.used_prompts = [];
      statusEl.innerText = "üîÑ All prompts completed! Starting over...";
    }

    // Pick a random available prompt
    const promptsToChooseFrom = availablePrompts.length > 0 ? availablePrompts : allPrompts;
    const selectedPrompt = promptsToChooseFrom[Math.floor(Math.random() * promptsToChooseFrom.length)];

    // Mark as used
    session.used_prompts.push(selectedPrompt.text);

    // Update session with current prompt
    session.prompt_text = selectedPrompt.text;
    session.prompt_type = selectedPrompt.type;
    session.expected_answer = selectedPrompt.expected_answers[0]; // Use first expected answer for semantic evaluation

    promptEl.innerText = `Object: ${session.object}\n${selectedPrompt.type === "question" ? "Question" : "Sentence"}: ${session.prompt_text}`;
    startBtn.disabled = false;
    statusEl.innerText = `Prompt ${session.used_prompts.length}/${allPrompts.length} ready. Click 'Start Recording' to answer.`;
  } catch (e) {
    console.error(e);
    statusEl.innerText = "Could not get prompt: " + e.message;
    startBtn.disabled = true;
  }
}

// Check Ollama status on page load
async function checkOllamaStatus() {
  try {
    const response = await fetch(`${BACKEND}/ollama/status`);
    const data = await response.json();
    ollamaStatusEl.innerText = data.available ? "üü¢ LLM Ready" : "üü° Fallback Mode";
    ollamaStatusEl.title = data.message;
  } catch (e) {
    ollamaStatusEl.innerText = "üü° Fallback Mode";
  }
}

// Generate prompts for the entered object
async function generatePromptsForObject() {
  const objectName = objectNameInput.value.trim();

  if (!objectName) {
    statusEl.innerText = "‚ö†Ô∏è Please enter an object name";
    return;
  }

  // Disable button and show loading state
  generatePromptsBtn.disabled = true;
  generatePromptsBtn.innerText = "Generating...";
  statusEl.innerText = `Generating prompts for "${objectName}"...`;
  ollamaStatusEl.innerText = "‚è≥ Processing...";

  try {
    const formData = new FormData();
    formData.append("object_name", objectName);

    const response = await fetch(`${BACKEND}/generate-prompts`, {
      method: "POST",
      body: formData
    });

    if (!response.ok) throw new Error("Failed to generate prompts");

    const data = await response.json();
    generatedPrompts = data;

    // Update UI
    const sourceIcon = data.source === "llm" ? "ü§ñ" : data.source === "cache" ? "üíæ" : "üìù";
    const sourceText = data.source === "llm" ? "LLM Generated" : data.source === "cache" ? "From Cache" : "Template";

    promptEl.innerHTML = `<strong>Object: ${data.object}</strong><br>
      <small style="color: #666;">${sourceIcon} ${sourceText} | ${data.questions.length} questions, ${data.sentences.length} sentences</small><br><br>
      Click "Get Prompt" to start practicing!`;

    // Enable the Get Prompt button
    getBtn.disabled = false;
    getBtn.style.background = "#4CAF50";

    // Lock the object input
    objectNameInput.disabled = true;
    generatePromptsBtn.disabled = true;

    statusEl.innerText = `‚úì Prompts ready for "${objectName}"! Click "Get Prompt" to begin.`;
    ollamaStatusEl.innerText = sourceIcon + " " + sourceText;

  } catch (e) {
    console.error(e);
    statusEl.innerText = "‚ùå Could not generate prompts: " + e.message;
    generatePromptsBtn.disabled = false;
    generatePromptsBtn.innerText = "Generate Prompts";
    checkOllamaStatus(); // Restore status
  }
}

getBtn.addEventListener("click", getPrompt);
generatePromptsBtn.addEventListener("click", generatePromptsForObject);

// Check Ollama status when page loads
checkOllamaStatus();

async function newObject() {
  // Reset to allow entering a new object
  session = null;
  generatedPrompts = null;

  // Re-enable object input
  objectNameInput.disabled = false;
  objectNameInput.value = "";
  generatePromptsBtn.disabled = false;
  generatePromptsBtn.innerText = "Generate Prompts";

  // Disable Get Prompt button until new object is generated
  getBtn.disabled = true;
  getBtn.style.background = "";

  // Clear displays
  promptEl.innerText = "Enter a new object and click 'Generate Prompts'";
  resultEl.innerHTML = "";
  statusEl.innerText = "Ready for new object";

  // Hide New Object button and session info
  newObjBtn.style.display = "none";
  sessionInfoEl.classList.remove('active');

  // Keep patient ID locked if it was already set
  // (patient can continue with same ID across multiple objects)
}

newObjBtn.addEventListener("click", newObject);

startBtn.addEventListener("click", async () => {
  startBtn.disabled = true;
  stopBtn.disabled = false;
  statusEl.innerText = "Requesting microphone permission...";
  audioChunks = [];

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = e => {
      if (e.data && e.data.size > 0) audioChunks.push(e.data);
    };
    mediaRecorder.onstop = async () => {
      statusEl.innerText = "Recording stopped. Uploading...";
      const blob = new Blob(audioChunks, { type: "audio/webm" });
      await uploadRecording(blob);
    };

    // Setup simple client-side VAD (energy-based)
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      sourceNode.connect(analyser);
      monitorSilence(); // start monitoring
    } catch (e) {
      console.warn("AudioContext VAD not available", e);
    }

    mediaRecorder.start();
    statusEl.innerText = "Recording... Speak now.";
    // fallback auto-stop after 8 seconds
    setTimeout(() => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        stopRecording();
      }
    }, 8000);

  } catch (err) {
    console.error("microphone error", err);
    statusEl.innerText = "Microphone error: " + err.message;
    startBtn.disabled = false;
    stopBtn.disabled = true;
  }
});

stopBtn.addEventListener("click", stopRecording);

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === "recording") {
    mediaRecorder.stop();
  }
  stopBtn.disabled = true;
  startBtn.disabled = false;
  if (audioContext) {
    try { audioContext.close(); } catch(e){}
    audioContext = null;
    analyser = null;
  }
}

function monitorSilence() {
  const bufferLength = analyser.fftSize;
  const data = new Uint8Array(bufferLength);
  const check = () => {
    if (!analyser) return;
    analyser.getByteTimeDomainData(data);
    let sum = 0;
    for (let i = 0; i < bufferLength; i++) {
      const val = (data[i] - 128) / 128;
      sum += val * val;
    }
    const rms = Math.sqrt(sum / bufferLength);
    // threshold tuned for quiet rooms; raise if your environment is noisy
    if (rms > 0.02) {
      if (silenceTimeout) {
        clearTimeout(silenceTimeout);
        silenceTimeout = null;
      }
      silenceTimeout = setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          stopRecording();
        }
      }, 2000); // stop after 2000ms of silence
    }
    requestAnimationFrame(check);
  };
  check();
}

async function uploadRecording(blob) {
  if (!session) {
    statusEl.innerText = "No session info found. Click Get Prompt first.";
    return;
  }

  const form = new FormData();
  form.append("session_id", session.session_id);
  form.append("object_name", session.object);
  form.append("prompt_text", session.prompt_text);
  form.append("expected_answer", session.expected_answer || "");
  // name the file .webm ‚Äî backend will accept common formats if ffmpeg in PATH
  form.append("audio", blob, "recording.webm");

  try {
    const res = await fetch(`${BACKEND}/record`, { method: "POST", body: form });
    if (!res.ok) {
      const txt = await res.text();
      throw new Error(`Server returned ${res.status}: ${txt}`);
    }
    const json = await res.json();
    displayResults(json);
    statusEl.innerText = "Analysis complete";
  } catch (e) {
    statusEl.innerText = "Upload failed: " + e.message;
    resultEl.innerText = "";
    console.error("upload error", e);
  }
}

function displayResults(data) {
  // Create a formatted display of results
  let html = "<h3>Analysis Results</h3>";

  // Display transcript
  html += `<div><strong>Transcript:</strong> ${data.transcript || "(no speech detected)"}</div>`;

  // Display semantic evaluation if present
  if (data.semantic_evaluation) {
    const eval = data.semantic_evaluation;
    const classColor = {
      "correct": "#2ecc71",
      "partial": "#f39c12",
      "wrong": "#e74c3c"
    }[eval.classification] || "#333";

    html += `<div style="margin-top: 15px; padding: 10px; background-color: #f8f8f8; border-radius: 6px;">`;
    html += `<h4>Semantic Evaluation</h4>`;
    html += `<div><strong>Classification:</strong> <span style="color: ${classColor}; font-weight: bold;">${eval.classification.toUpperCase()}</span></div>`;
    html += `<div><strong>Similarity Score:</strong> ${(eval.similarity_score * 100).toFixed(1)}%</div>`;
    html += `<div><strong>Confidence:</strong> ${(eval.confidence * 100).toFixed(0)}%</div>`;
    html += `<div><strong>Object Mentioned:</strong> ${eval.object_mentioned ? "Yes" : "No"}</div>`;
    html += `<div><strong>Explanation:</strong> ${eval.explanation}</div>`;

    // Display semantic features if present
    if (eval.semantic_features) {
      html += `<div style="margin-top: 10px;"><strong>Clinical Insights:</strong>`;
      html += `<ul style="margin: 5px 0;">`;
      html += `<li>Word count: ${eval.semantic_features.word_count || 0}</li>`;
      if (eval.semantic_features.response_type) {
        html += `<li>Response type: ${eval.semantic_features.response_type}</li>`;
      }
      if (eval.semantic_features.has_paraphrase) {
        html += `<li>Paraphrasing detected (${eval.semantic_features.paraphrase_quality})</li>`;
      }
      if (eval.semantic_features.substituted_term) {
        html += `<li>Word substitution: "${eval.semantic_features.substituted_term}"</li>`;
      }
      html += `</ul></div>`;
    }
    html += `</div>`;
  }

  // Display phoneme analysis if present
  if (data.phoneme_analysis && !data.phoneme_analysis.error) {
    const phoneme = data.phoneme_analysis;
    html += `<div style="margin-top: 15px; padding: 10px; background-color: #e8f4f8; border-radius: 6px;">`;
    html += `<h4>Phoneme-Level Analysis</h4>`;
    html += `<div><strong>Phoneme Error Rate (PER):</strong> ${(phoneme.per * 100).toFixed(1)}%</div>`;
    html += `<div><strong>Total Phonemes:</strong> ${phoneme.total_phonemes}</div>`;
    html += `<div><strong>Errors Detected:</strong> ${phoneme.error_count}</div>`;

    // Error breakdown
    if (phoneme.error_summary) {
      html += `<div style="margin-top: 8px;"><strong>Error Types:</strong>`;
      html += `<ul style="margin: 5px 0;">`;
      if (phoneme.error_summary.substitution > 0) {
        html += `<li>Substitutions: ${phoneme.error_summary.substitution}</li>`;
      }
      if (phoneme.error_summary.deletion > 0) {
        html += `<li>Deletions: ${phoneme.error_summary.deletion}</li>`;
      }
      if (phoneme.error_summary.insertion > 0) {
        html += `<li>Insertions: ${phoneme.error_summary.insertion}</li>`;
      }
      html += `</ul></div>`;
    }

    // Problematic phonemes
    if (phoneme.problematic_phonemes && Object.keys(phoneme.problematic_phonemes).length > 0) {
      html += `<div style="margin-top: 8px;"><strong>Problematic Phonemes:</strong> `;
      const problems = Object.entries(phoneme.problematic_phonemes)
        .map(([ph, count]) => `${ph} (${count}x)`)
        .join(', ');
      html += `${problems}</div>`;
    }

    // Clinical notes
    if (phoneme.clinical_notes && phoneme.clinical_notes.length > 0) {
      html += `<div style="margin-top: 10px; padding: 8px; background-color: #fff3cd; border-left: 3px solid #ffc107;">`;
      html += `<strong>Clinical Insights:</strong>`;
      html += `<ul style="margin: 5px 0;">`;
      phoneme.clinical_notes.forEach(note => {
        html += `<li>${note}</li>`;
      });
      html += `</ul></div>`;
    }

    // Detailed errors (collapsible)
    if (phoneme.errors && phoneme.errors.length > 0) {
      html += `<details style="margin-top: 10px;">`;
      html += `<summary style="cursor: pointer; font-weight: bold;">Detailed Phoneme Errors (${phoneme.errors.length})</summary>`;
      html += `<table style="width: 100%; margin-top: 8px; border-collapse: collapse; font-size: 12px;">`;
      html += `<tr style="background-color: #f0f0f0;"><th>Type</th><th>Word</th><th>Expected</th><th>Actual</th><th>Position</th></tr>`;
      phoneme.errors.forEach(err => {
        const errorTypeColor = {
          'substitution': '#ff9800',
          'deletion': '#f44336',
          'insertion': '#2196f3'
        }[err.type] || '#333';
        html += `<tr style="border-bottom: 1px solid #ddd;">`;
        html += `<td style="padding: 4px; color: ${errorTypeColor}; font-weight: bold;">${err.type}</td>`;
        html += `<td style="padding: 4px;">${err.word || '-'}</td>`;
        html += `<td style="padding: 4px;">${err.expected || '-'}</td>`;
        html += `<td style="padding: 4px;">${err.actual || '-'}</td>`;
        html += `<td style="padding: 4px;">${err.position}</td>`;
        html += `</tr>`;
      });
      html += `</table></details>`;
    }
    html += `</div>`;
  }

  // Display fluency analysis if present (handles both standard and enhanced formats)
  if (data.fluency_analysis && !data.fluency_analysis.error) {
    const fluency = data.fluency_analysis;
    html += `<div style="margin-top: 15px; padding: 10px; background-color: #f0f8ff; border-radius: 6px;">`;
    html += `<h4>Fluency & Stuttering Analysis</h4>`;

    // Key metrics - handle both old and new format
    html += `<div><strong>Longest Fluent Run:</strong> ${fluency.longest_fluent_run || 0} words</div>`;

    // Check for enhanced format (fluency_scores object) vs standard format
    if (fluency.fluency_scores) {
      // Enhanced format
      html += `<div><strong>Weighted Fluency:</strong> ${(fluency.fluency_scores.weighted_fluency_pct || 0).toFixed(1)}%</div>`;
      html += `<div><strong>Clinical Fluency:</strong> ${(fluency.fluency_scores.clinical_fluency_pct || 0).toFixed(1)}%</div>`;
    } else if (fluency.fluency_percentage !== undefined) {
      // Standard format
      html += `<div><strong>Fluency Percentage:</strong> ${fluency.fluency_percentage.toFixed(1)}%</div>`;
      if (fluency.dysfluencies_per_100_words !== undefined) {
        html += `<div><strong>Dysfluencies per 100 words:</strong> ${fluency.dysfluencies_per_100_words.toFixed(1)}</div>`;
      }
      if (fluency.dysfluencies_per_minute !== undefined) {
        html += `<div><strong>Dysfluencies per minute:</strong> ${fluency.dysfluencies_per_minute.toFixed(1)}</div>`;
      }
    }

    // Speech rate metrics (enhanced format)
    if (fluency.speech_rate_metrics) {
      const sr = fluency.speech_rate_metrics;
      html += `<div style="margin-top: 8px;"><strong>Speech Rate:</strong> ${sr.speaking_rate || 0} syl/min</div>`;
      html += `<div><strong>Articulation Rate:</strong> ${sr.articulation_rate || 0} syl/min</div>`;
      if (sr.normative_comparison) {
        html += `<div><em>${sr.normative_comparison}</em></div>`;
      }
    }

    // SSI-4 Stuttering Severity (enhanced format)
    if (fluency.ssi_approximation && fluency.ssi_approximation.severity !== 'normal') {
      const ssi = fluency.ssi_approximation;
      html += `<div style="margin-top: 8px; padding: 6px; background: #ffebee; border-radius: 4px;">`;
      html += `<strong>Stuttering Severity (SSI-4):</strong> ${ssi.severity.replace('_', ' ')} (score: ${ssi.total_score})`;
      html += `</div>`;
    }

    // Pause breakdown - handle both formats
    const pauseMetrics = fluency.pause_metrics || {};
    const totalPauses = pauseMetrics.total_pauses || fluency.total_pauses || 0;
    if (totalPauses > 0) {
      const hesitations = pauseMetrics.hesitation_count || fluency.hesitation_count || 0;
      const blocks = pauseMetrics.block_count || fluency.block_count || 0;
      const anomic = pauseMetrics.anomic_count || 0;
      html += `<div style="margin-top: 8px;"><strong>Pauses Detected:</strong> ${totalPauses}`;
      if (hesitations > 0) html += ` (${hesitations} hesitations`;
      if (anomic > 0) html += `, ${anomic} word-finding`;
      if (blocks > 0) html += `, ${blocks} blocks`;
      html += `)</div>`;
    }

    // Stuttering events summary
    if (fluency.stuttering_events && fluency.stuttering_events.length > 0) {
      const repetitions = fluency.stuttering_events.filter(e => e.type === 'repetition' || e.type === 'whole_word_repetition').length;
      const interjections = fluency.stuttering_events.filter(e => e.type === 'interjection').length;
      const prolongations = fluency.stuttering_events.filter(e => e.type === 'prolongation').length;

      html += `<div style="margin-top: 8px;"><strong>Stuttering Events:</strong> ${fluency.stuttering_events.length}`;
      if (repetitions > 0) html += ` (${repetitions} repetition(s)`;
      if (interjections > 0) html += `, ${interjections} interjection(s)`;
      if (prolongations > 0) html += `, ${prolongations} prolongation(s)`;
      html += `)</div>`;
    }

    // Clinical notes
    if (fluency.clinical_notes && fluency.clinical_notes.length > 0) {
      html += `<div style="margin-top: 10px; padding: 8px; background-color: #fff3cd; border-left: 3px solid #ffc107;">`;
      html += `<strong>Fluency Insights:</strong>`;
      html += `<ul style="margin: 5px 0;">`;
      fluency.clinical_notes.forEach(note => {
        html += `<li>${note}</li>`;
      });
      html += `</ul></div>`;
    }

    // Detailed stuttering events (collapsible)
    if (fluency.stuttering_events && fluency.stuttering_events.length > 0) {
      html += `<details style="margin-top: 10px;">`;
      html += `<summary style="cursor: pointer; font-weight: bold;">Detailed Stuttering Events (${fluency.stuttering_events.length})</summary>`;
      html += `<table style="width: 100%; margin-top: 8px; border-collapse: collapse; font-size: 12px;">`;
      html += `<tr style="background-color: #f0f0f0;"><th>Type</th><th>Position</th><th>Word</th><th>Details</th></tr>`;
      fluency.stuttering_events.forEach(event => {
        const typeColor = {
          'repetition': '#ff9800',
          'whole_word_repetition': '#ff9800',
          'interjection': '#9c27b0',
          'prolongation': '#f44336'
        }[event.type] || '#333';

        let details = '';
        if (event.type === 'repetition' || event.type === 'whole_word_repetition') {
          details = `Repeated ${event.repetition_count || 2}x`;
        } else if (event.type === 'prolongation' && event.duration) {
          details = `Duration: ${event.duration.toFixed(2)}s`;
        } else if (event.clinical_significance) {
          details = event.clinical_significance;
        }

        html += `<tr style="border-bottom: 1px solid #ddd;">`;
        html += `<td style="padding: 4px; color: ${typeColor}; font-weight: bold;">${event.type}</td>`;
        html += `<td style="padding: 4px;">${event.position}</td>`;
        html += `<td style="padding: 4px;">${event.word}</td>`;
        html += `<td style="padding: 4px;">${details}</td>`;
        html += `</tr>`;
      });
      html += `</table></details>`;
    }

    // Detailed pauses (collapsible)
    if (fluency.pauses && fluency.pauses.length > 0) {
      html += `<details style="margin-top: 10px;">`;
      html += `<summary style="cursor: pointer; font-weight: bold;">Detailed Pauses (${fluency.pauses.length})</summary>`;
      html += `<table style="width: 100%; margin-top: 8px; border-collapse: collapse; font-size: 12px;">`;
      html += `<tr style="background-color: #f0f0f0;"><th>Type</th><th>Duration</th><th>Location</th><th>Context</th></tr>`;
      fluency.pauses.forEach(pause => {
        const pauseColor = pause.type === 'block' ? '#f44336' : '#ff9800';
        html += `<tr style="border-bottom: 1px solid #ddd;">`;
        html += `<td style="padding: 4px; color: ${pauseColor}; font-weight: bold;">${pause.type}</td>`;
        html += `<td style="padding: 4px;">${pause.duration.toFixed(2)}s</td>`;
        html += `<td style="padding: 4px;">${pause.location}</td>`;
        html += `<td style="padding: 4px;">${pause.before_word || '?'} ‚Üí ${pause.after_word || '?'}</td>`;
        html += `</tr>`;
      });
      html += `</table></details>`;
    }

    html += `</div>`;
  }

  // Display other metrics
  html += `<div style="margin-top: 15px;">`;
  html += `<h4>Speech Metrics</h4>`;
  if (data.wer !== null) {
    html += `<div><strong>Word Error Rate (WER):</strong> ${(data.wer * 100).toFixed(1)}%</div>`;
  }
  html += `<div><strong>Speech Rate:</strong> ${data.speech_rate ? data.speech_rate.toFixed(1) : "N/A"} words/min</div>`;
  html += `<div><strong>Pause Ratio:</strong> ${data.pause_ratio ? (data.pause_ratio * 100).toFixed(1) : "N/A"}%</div>`;
  html += `</div>`;

  // Show raw JSON in collapsible section
  html += `<details style="margin-top: 15px;">`;
  html += `<summary style="cursor: pointer;">Raw JSON Response</summary>`;
  html += `<pre style="margin-top: 10px;">${JSON.stringify(data, null, 2)}</pre>`;
  html += `</details>`;

  resultEl.innerHTML = html;
}
</script>
</body>
</html>
