<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Speech Homework Demo</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width:700px; }
    h2 { margin-bottom: 6px; }
    #prompt { font-size: 18px; margin: 10px 0; white-space: pre-wrap; }
    button { padding: 8px 12px; margin-right: 8px; }
    #status { margin-top: 10px; color: #333; }
    pre { background:#f3f3f3; padding:10px; border-radius:6px; max-height:300px; overflow:auto; }
    .warn { color: darkred; }
  </style>
</head>
<body>
  <h2>Speech Homework Demo</h2>
  <div id="prompt">Click "Get Prompt" to start</div>
  <button id="getPrompt">Get Prompt</button>
  <button id="newObject" style="display: none;">New Object</button>
  <button id="startRec" disabled>Start Recording</button>
  <button id="stopRec" disabled>Stop</button>
  <div id="status"></div>
  <pre id="result"></pre>

<script>
/* ======== CONFIG ======== */
const BACKEND = "http://127.0.0.1:8000"; // <-- make sure this matches your backend
/* ======================== */

const promptEl = document.getElementById("prompt");
const getBtn = document.getElementById("getPrompt");
const newObjBtn = document.getElementById("newObject");
const startBtn = document.getElementById("startRec");
const stopBtn = document.getElementById("stopRec");
const statusEl = document.getElementById("status");
const resultEl = document.getElementById("result");

let session = null;
let mediaRecorder = null;
let audioChunks = [];
let silenceTimeout = null;
let audioContext, analyser, sourceNode;

async function getPrompt() {
  statusEl.innerText = "Requesting prompt...";
  try {
    let response, json;

    if (!session || !session.session_id) {
      // First time - start a new session
      response = await fetch(`${BACKEND}/session/start`, { method: "POST" });
      if (!response.ok) throw new Error("Failed to start session");
      json = await response.json();

      // Show the "New Object" button after first session starts
      newObjBtn.style.display = "inline-block";
    } else {
      // Already have a session - get next prompt for same object
      const formData = new FormData();
      formData.append("session_id", session.session_id);

      response = await fetch(`${BACKEND}/session/next-prompt`, {
        method: "POST",
        body: formData
      });
      if (!response.ok) throw new Error("Failed to get next prompt");
      json = await response.json();
    }

    // Update session data
    session = {
      session_id: json.session_id,
      prompt_text: json.prompt_text,
      object: json.object,
      expected_answer: json.expected_answer
    };

    promptEl.innerText = `Object: ${session.object}\nPrompt: ${session.prompt_text}`;
    startBtn.disabled = false;
    statusEl.innerText = "Prompt ready. Click 'Start Recording' to answer.";
  } catch (e) {
    console.error(e);
    statusEl.innerText = "Could not fetch prompt. Is backend running? " + e.message;
    startBtn.disabled = true;
  }
}

getBtn.addEventListener("click", getPrompt);

async function newObject() {
  if (!session || !session.session_id) {
    statusEl.innerText = "Please get a prompt first before changing objects.";
    return;
  }

  statusEl.innerText = "Getting new object...";
  try {
    const formData = new FormData();
    formData.append("session_id", session.session_id);

    const response = await fetch(`${BACKEND}/session/change-object`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) throw new Error("Failed to change object");
    const json = await response.json();

    // Update session data
    session = {
      session_id: json.session_id,
      prompt_text: json.prompt_text,
      object: json.object,
      expected_answer: json.expected_answer
    };

    promptEl.innerText = `Object: ${session.object}\nPrompt: ${session.prompt_text}`;
    startBtn.disabled = false;
    statusEl.innerText = "New object selected. Click 'Start Recording' to answer.";
    resultEl.innerHTML = ""; // Clear previous results
  } catch (e) {
    console.error(e);
    statusEl.innerText = "Could not change object: " + e.message;
  }
}

newObjBtn.addEventListener("click", newObject);

startBtn.addEventListener("click", async () => {
  startBtn.disabled = true;
  stopBtn.disabled = false;
  statusEl.innerText = "Requesting microphone permission...";
  audioChunks = [];

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = e => {
      if (e.data && e.data.size > 0) audioChunks.push(e.data);
    };
    mediaRecorder.onstop = async () => {
      statusEl.innerText = "Recording stopped. Uploading...";
      const blob = new Blob(audioChunks, { type: "audio/webm" });
      await uploadRecording(blob);
    };

    // Setup simple client-side VAD (energy-based)
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      sourceNode.connect(analyser);
      monitorSilence(); // start monitoring
    } catch (e) {
      console.warn("AudioContext VAD not available", e);
    }

    mediaRecorder.start();
    statusEl.innerText = "Recording... Speak now.";
    // fallback auto-stop after 8 seconds
    setTimeout(() => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        stopRecording();
      }
    }, 8000);

  } catch (err) {
    console.error("microphone error", err);
    statusEl.innerText = "Microphone error: " + err.message;
    startBtn.disabled = false;
    stopBtn.disabled = true;
  }
});

stopBtn.addEventListener("click", stopRecording);

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === "recording") {
    mediaRecorder.stop();
  }
  stopBtn.disabled = true;
  startBtn.disabled = false;
  if (audioContext) {
    try { audioContext.close(); } catch(e){}
    audioContext = null;
    analyser = null;
  }
}

function monitorSilence() {
  const bufferLength = analyser.fftSize;
  const data = new Uint8Array(bufferLength);
  const check = () => {
    if (!analyser) return;
    analyser.getByteTimeDomainData(data);
    let sum = 0;
    for (let i = 0; i < bufferLength; i++) {
      const val = (data[i] - 128) / 128;
      sum += val * val;
    }
    const rms = Math.sqrt(sum / bufferLength);
    // threshold tuned for quiet rooms; raise if your environment is noisy
    if (rms > 0.02) {
      if (silenceTimeout) {
        clearTimeout(silenceTimeout);
        silenceTimeout = null;
      }
      silenceTimeout = setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          stopRecording();
        }
      }, 900); // stop after 900ms of silence
    }
    requestAnimationFrame(check);
  };
  check();
}

async function uploadRecording(blob) {
  if (!session) {
    statusEl.innerText = "No session info found. Click Get Prompt first.";
    return;
  }

  const form = new FormData();
  form.append("session_id", session.session_id);
  form.append("object_name", session.object);
  form.append("prompt_text", session.prompt_text);
  form.append("expected_answer", session.expected_answer || "");
  // name the file .webm â€” backend will accept common formats if ffmpeg in PATH
  form.append("audio", blob, "recording.webm");

  try {
    const res = await fetch(`${BACKEND}/record`, { method: "POST", body: form });
    if (!res.ok) {
      const txt = await res.text();
      throw new Error(`Server returned ${res.status}: ${txt}`);
    }
    const json = await res.json();
    displayResults(json);
    statusEl.innerText = "Analysis complete";
  } catch (e) {
    statusEl.innerText = "Upload failed: " + e.message;
    resultEl.innerText = "";
    console.error("upload error", e);
  }
}

function displayResults(data) {
  // Create a formatted display of results
  let html = "<h3>Analysis Results</h3>";

  // Display transcript
  html += `<div><strong>Transcript:</strong> ${data.transcript || "(no speech detected)"}</div>`;

  // Display semantic evaluation if present
  if (data.semantic_evaluation) {
    const eval = data.semantic_evaluation;
    const classColor = {
      "correct": "#2ecc71",
      "partial": "#f39c12",
      "wrong": "#e74c3c"
    }[eval.classification] || "#333";

    html += `<div style="margin-top: 15px; padding: 10px; background-color: #f8f8f8; border-radius: 6px;">`;
    html += `<h4>Semantic Evaluation</h4>`;
    html += `<div><strong>Classification:</strong> <span style="color: ${classColor}; font-weight: bold;">${eval.classification.toUpperCase()}</span></div>`;
    html += `<div><strong>Similarity Score:</strong> ${(eval.similarity_score * 100).toFixed(1)}%</div>`;
    html += `<div><strong>Confidence:</strong> ${(eval.confidence * 100).toFixed(0)}%</div>`;
    html += `<div><strong>Object Mentioned:</strong> ${eval.object_mentioned ? "Yes" : "No"}</div>`;
    html += `<div><strong>Explanation:</strong> ${eval.explanation}</div>`;

    // Display semantic features if present
    if (eval.semantic_features) {
      html += `<div style="margin-top: 10px;"><strong>Clinical Insights:</strong>`;
      html += `<ul style="margin: 5px 0;">`;
      html += `<li>Word count: ${eval.semantic_features.word_count || 0}</li>`;
      if (eval.semantic_features.response_type) {
        html += `<li>Response type: ${eval.semantic_features.response_type}</li>`;
      }
      if (eval.semantic_features.has_paraphrase) {
        html += `<li>Paraphrasing detected (${eval.semantic_features.paraphrase_quality})</li>`;
      }
      if (eval.semantic_features.substituted_term) {
        html += `<li>Word substitution: "${eval.semantic_features.substituted_term}"</li>`;
      }
      html += `</ul></div>`;
    }
    html += `</div>`;
  }

  // Display other metrics
  html += `<div style="margin-top: 15px;">`;
  html += `<h4>Speech Metrics</h4>`;
  if (data.wer !== null) {
    html += `<div><strong>Word Error Rate (WER):</strong> ${(data.wer * 100).toFixed(1)}%</div>`;
  }
  html += `<div><strong>Speech Rate:</strong> ${data.speech_rate ? data.speech_rate.toFixed(1) : "N/A"} words/min</div>`;
  html += `<div><strong>Pause Ratio:</strong> ${data.pause_ratio ? (data.pause_ratio * 100).toFixed(1) : "N/A"}%</div>`;
  html += `</div>`;

  // Show raw JSON in collapsible section
  html += `<details style="margin-top: 15px;">`;
  html += `<summary style="cursor: pointer;">Raw JSON Response</summary>`;
  html += `<pre style="margin-top: 10px;">${JSON.stringify(data, null, 2)}</pre>`;
  html += `</details>`;

  resultEl.innerHTML = html;
}
</script>
</body>
</html>
